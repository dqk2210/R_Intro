```markdown
# BÀI 6: DATAFRAME - CẤU TRÚC DỮ LIỆU BẢNG TRONG R

## 1. Giới thiệu về Dataframe
Nếu `Vector` là nền tảng, `Matrix` là bảng tính đồng nhất, thì **Dataframe** chính là "trái tim" của phân tích dữ liệu trong R.

* **Định nghĩa:** Dataframe là một danh sách (list) các vector có cùng độ dài.
* **Đặc điểm:**
    * Cấu trúc dạng bảng (hàng và cột).
    * **Quan trọng:** Các cột khác nhau có thể chứa các kiểu dữ liệu khác nhau (Ví dụ: Cột 1 là Tên (Character), Cột 2 là Tuổi (Numeric), Cột 3 là Đã tốt nghiệp (Logical)).
    * Tương đương với một "Sheet" trong Excel hoặc một bảng trong SQL.

---

## 2. Tạo và Kiểm tra Dataframe

### 2.1. Tạo Dataframe thủ công
Chúng ta ghép các vector lại với nhau bằng hàm `data.frame()`.

```{r}
# Tạo các vector thành phần
column1 <- c(1:3)                   # Số nguyên
column2 <- c("Tung", "Tom", "Anna") # Ký tự
column3 <- c(TRUE, TRUE, FALSE)     # Logic

# Ghép thành dataframe
dataset1 <- data.frame(column1, column2, column3)

# Xem kết quả
print(dataset1)

```

### 2.2. Đổi tên cột (Column Names)

Tên cột mặc định sẽ là tên biến vector. Để đổi tên cho dễ hiểu:

```{r}
# Đổi tên tất cả các cột
colnames(dataset1) <- c("ID", "Name", "Passed")

# Đổi tên một cột cụ thể (ví dụ cột 2)
colnames(dataset1)[2] <- "StudentName"

```

### 2.3. Kiểm tra dữ liệu (Rất quan trọng)

Trước khi phân tích, luôn phải kiểm tra cấu trúc dữ liệu.

```{r}
head(dataset1)    # Xem vài dòng đầu
tail(dataset1)    # Xem vài dòng cuối
str(dataset1)     # Xem cấu trúc (kiểu dữ liệu từng cột)
summary(dataset1) # Tóm tắt thống kê (Min, Max, Mean...)
dim(dataset1)     # Kích thước (Số hàng x Số cột)

```

---

## 3. Truy xuất và Thao tác dữ liệu

### 3.1. Truy xuất (Indexing)

Có 3 cách chính để lấy dữ liệu từ Dataframe:

1. **Theo tọa độ Matrix `[hàng, cột]`:**
```{r}
dataset1[1, 2] # Lấy dòng 1, cột 2

```


2. **Theo tên cột (trả về Vector) - Dùng dấu `$`: ** *(Phổ biến nhất)*
```{r}
dataset1$StudentName

```


3. **Theo tên cột (trả về Dataframe con) - Dùng `[]`:**
```{r}
dataset1["StudentName"]

```



### 3.2. Mở rộng Dataframe

* **Thêm cột mới (`cbind` hoặc `$`):**
```{r}
# Cách 1: Dùng $ (Khuyên dùng)
dataset1$Score <- c(8.5, 9.0, 7.5)

# Cách 2: Dùng cbind
new_col <- c("HN", "HCM", "DN")
dataset1 <- cbind(dataset1, Location = new_col)

```


* **Thêm dòng mới (`rbind`):**
*Lưu ý: Dòng mới phải có cùng số lượng cột và tên cột tương ứng.*
```{r}
newRow <- data.frame(ID = 4, StudentName = "Duong", Passed = TRUE, Score = 8.0, Location = "Hue")
dataset1 <- rbind(dataset1, newRow)

```



---

## 4. Các thao tác nâng cao (Data Wrangling)

### 4.1. Sắp xếp dữ liệu (Sorting)

Sử dụng hàm `order()` để lấy chỉ số index đã sắp xếp, sau đó áp dụng vào dataframe.

```{r}
# Sắp xếp theo ID tăng dần
dataset1[order(dataset1$ID), ]

# Sắp xếp theo Score giảm dần (decreasing = TRUE)
dataset1[order(dataset1$Score, decreasing = TRUE), ]

```

### 4.2. Lọc dữ liệu (Filtering)

Lọc ra các dòng thỏa mãn điều kiện.

```{r}
# Cách 1: Dùng chỉ số logic (Boolean Indexing)
# Lấy sinh viên đã đậu (Passed == TRUE)
passed_students <- dataset1[dataset1$Passed == TRUE, ]

# Cách 2: Dùng hàm subset() (Dễ đọc hơn)
# Lấy sinh viên đậu VÀ điểm > 8
good_students <- subset(dataset1, Passed == TRUE & Score > 8)

```

### 4.3. Gộp bảng dữ liệu (Merging / Joins)

Tương tự như SQL, R dùng hàm `merge()` để nối hai bảng dựa trên một cột khóa (Key).

Giả sử ta có 2 bảng:

* `set1`: Chứa thông tin sản phẩm (Key: IdClient)
* `set2`: Chứa thông tin vùng miền (Key: IdClient)

```{r}
# 1. Inner Join (Chỉ lấy phần chung có ở cả 2 bảng)
merge(set1, set2, by = "IdClient")

# 2. Outer Join (Lấy tất cả, thiếu điền NA)
merge(set1, set2, by = "IdClient", all = TRUE)

# 3. Left Join (Giữ nguyên bảng bên trái set1, tìm bảng phải ghép vào)
merge(set1, set2, by = "IdClient", all.x = TRUE)

```

---

## 5. Làm sạch dữ liệu (Data Cleaning)

Dữ liệu thực tế thường bị khuyết thiếu (`NA`).

### 5.1. Phát hiện dữ liệu thiếu

```{r}
is.na(dataset1)        # Kiểm tra toàn bộ bảng
sum(is.na(dataset1))   # Đếm tổng số ô bị thiếu

```

### 5.2. Xử lý dữ liệu thiếu

1. **Xóa dòng thiếu (`complete.cases`):**
```{r}
# Chỉ giữ lại các dòng đầy đủ dữ liệu
clean_data <- dataset1[complete.cases(dataset1), ]

```


2. **Điền dữ liệu thiếu (Imputation):**
```{r}
# Điền NA bằng giá trị trung bình
mean_val <- mean(dataset1$Score, na.rm = TRUE)
dataset1$Score[is.na(dataset1$Score)] <- mean_val

```



---

## 6. Bài tập thực hành (Lab)

### Bài tập 1: Thao tác cơ bản với `iris`

Bộ dữ liệu `iris` có sẵn trong R.

1. Hiển thị các dòng từ 40 đến 120, nhưng chỉ lấy các dòng chia hết cho 3 (bước nhảy = 3).
2. **Gợi ý:** Dùng `seq()`.

**Giải:**

```{r}
iris[seq(40, 120, 3), ]

```

### Bài tập 2: Phân tích bộ dữ liệu `CO2`

1. Lọc ra các cây có nguồn gốc (`Type`) là "Quebec" và điều trị (`Treatment`) là "chilled".
2. Tìm các mẫu có `uptake` > 40, sau đó sắp xếp kết quả theo nồng độ `conc` tăng dần.

**Giải:**

```{r}
# Câu 1
cau1 <- subset(CO2, Type == "Quebec" & Treatment == "chilled")

# Câu 2 (Kết hợp sort và filter)
temp <- CO2[CO2$uptake > 40, ]
ketqua <- temp[order(temp$conc), ]
# Hoặc viết gộp 1 dòng:
CO2[CO2$uptake > 40, ][order(CO2[CO2$uptake > 40, ]$conc), ]

```

### Bài tập 3: Xử lý dữ liệu thiếu (Advanced)

Cho bộ dữ liệu `missCO2` (đã tạo mã lỗi NA ngẫu nhiên).

1. Tìm các dòng có ít nhất 1 giá trị NA.
2. Điền các giá trị `uptake` bị thiếu bằng số 20.
3. Trích xuất số từ cột `weight` (ví dụ "30kg" -> 30) và lưu vào cột mới.

**Giải:**

```{r}
# 1. Tìm dòng thiếu (Sử dụng phủ định của complete.cases)
missCO2[!complete.cases(missCO2), ]

# 2. Điền giá trị 20
missCO2$uptake[is.na(missCO2$uptake)] <- 20

# 3. Xử lý chuỗi (Text processing)
# Dùng sub để thay thế chữ "kg" bằng rỗng, sau đó chuyển sang số
missCO2$weightNumber <- as.numeric(sub("kg", "", missCO2$weight))

```

---

## 7. Ghi nhớ (Key Takeaways)

1. **Dataframe** là cấu trúc quan trọng nhất cho Machine Learning và Thống kê trong R.
2. Dùng `$` để truy cập cột nhanh chóng.
3. Dùng `order()` để sắp xếp, `subset()` hoặc `[]` để lọc.
4. Luôn xử lý `NA` trước khi chạy mô hình phân tích.

```

```
